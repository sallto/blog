---
title: How to build an interactive Table of Contents
date: "2021-10-01"
tags: ["markdown", "code", "features"]
draft: false
desc: Build a great way for your readers to navigate articles.
---

In my pursuit of completely overengineering this blog, I got very hung up on the Table of Contents.
I wanted an aesthetically pleasing Table of Contents that automatically highlights the section you are reading.

I think I achieved this goal pretty well with the current solution. So let's learn how to do it.

## Getting the headings (from MDX)

The first major hurdle is fetching the headings from the data source you are using. In the worst-case `document.querySelectorAll()` is a viable option.

However, most developer blogs are written with some type of Markdown or [MDX](https://mdxjs.com/). So they are pretty much guaranteed to use the unified based parsers, such as **remark** and **rehype**.

This gives us automatic access to their respective plugin ecosystems, especially [rehype-slug](https://github.com/rehypejs/rehype-slug).
Using rehype-slug adds `id` attributes to all the headings.

For example:

```markdown
# Test Heading
```

will be transformed into

```html
<h1 id="test-heading">Test Heading</h1>
```

With the `id` attributes added, it is now possible to jump to the corresponding headings with a link.

The only thing left now is to extract the headings to a usable format.

### The power of remark plugins

We have discovered the power of remark plugins by now so how about builidng one ourselves to solve this issue.

In essence plugins are just transformers for the syntax trees the unified tools use internally.

One of our headings looks like this in the unified tree.

```js
{
  type: 'heading',
  depth: 2,
  children: [
    {
      type: 'text',
      value: 'Getting the headings (from MDX)',
      position: [Object]
    }
  ],
  position: {
    start: { line: 14, column: 1, offset: 507 },
    end: { line: 14, column: 35, offset: 541 }
  }
}
```

A plugin has acess to all nodes and can arbitrarily transform them.

```js
function remarkExtractTOC(){
    return tree => {...}
}
```

To effectively traverse the tree we will use the library `unist-util-visit` which exposes a visit function

```js
function remarkExtractTOC(){
    return tree => visit(tree,(node)=>{
        ...
    });
}
```

This allows us to iterate over all the nodes, but **note that tree-traversal gets expensive very fast**.
If build time becomes a concern you might want to traverse a tree only once and apply multiple transformations.

Since we only care abount headings we can use an optional second attribute to the `visit` function that creates a Test.
In our case the Test is very simple as `"heading"` suffices. If you want to build a more complicated filter, look at the [unist-util-is](https://unifiedjs.com/explore/package/unist-util-is/)
documentation. There are some very interesting possiblities.

When visiting a heading we want to grab the corresponding text. Similarily to most js frameworks, text is simply a child of type `text`.

```js
visit(tree, "heading", (node) => {
  const text = node.children[0].value;
});
```

For most cases this will work fine, but you might want to use a more sophisticated solution in production[^hast-util-to-string].
[^hast-util-to-string]: The best solution I know of is `hast-util-to-string`, which supports all kinds of text formatting such as **bolding**, but might open up XSS vurnerabilities.

Since we don't actually want to change the tree itself (we only want to extract information from it), we need some way to pass the text to the rest of the program.

To achieve this we will (ab)use the possiblity for remark plugins to have options.
We accept a (preferably empty) array as parameter and add our heading information to it.

```js
function remarkExtractTOC(options) {
  return (tree) =>
    visit(tree, "heading", (node) => {
      const title = node.children[0].value;
      options.headings.push({
        title: title,
      });
    });
}
```

Since the way to add plugins with options is different for most libraries i will not cover this. It should be quite easy to look up.

Other than the title we also want to add the url for each heading. Unluckily this information is not recorded in the tree object and as such has to be generated by us.

For this we will use `github-slugger`, which is based on githubs algrithm, but seems to match the behavior of `remark-slug` very well.

```js
function remarkExtractTOC(options) {
  return (tree) =>
    visit(tree, "heading", (node) => {
      const title = node.children[0].value;
      options.headings.push({
        title: title,
        url: "#" + slug(title),
      });
    });
}
```

Now we are all done and can actually build the Table of Contents.

**Note:** If you want hierarchy in your TOC you can add a depth attribute to the extracted headings.
I do not think this adds value so I will not be covering this.

## Building the Table of Contents

The basic structure of the TOC is very simple its simply a List with each listitem corresponding to one heading.

```jsx
function TableOfContents({ headings }) {
  return (
    <ul>
      {headings.map((heading) => (
        <li>
          <a href={heading.url}>{heading.title}</a>
        </li>
      ))}
    </ul>
  );
}
```

If we want interactivity it gets a bit more complicated.
As you probobly noticed by now, the currently active heading is always highlighted on this page.
